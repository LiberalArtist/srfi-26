<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>SRFI-26: Notation for Specializing Parameters without Currying</title>
  </head>

  <body>

<H1>Title</H1>

Notation for Specializing Parameters without Currying

<H1>Author</H1>

Sebastian Egner

<H1>Status</H1>

This SRFI is currently in ``draft'' status. To see an explanation of
each status that a SRFI can hold, see <a
href="http://srfi.schemers.org/srfi-process.html">here</a>.  It will
remain in draft until 2002-04-06, or as amended.  to provide input on
this SRFI, please
<a href="mailto:srfi-26@srfi.schemers.org">
mail to <code>srfi-26@srfi.schemers.org</code></a>.
See <a href="http://srfi.schemers.org/srfi-list-subscribe.html">
instructions here</a> to subscribe to the list.  You can access
previous messages via
<a href="http://srfi.schemers.org/srfi-26/mail-archive/maillist.html">
the archive of the mailing list</a>.

<UL>
<LI>Draft: 2002/02/06-2002/04/06 </LI>
<LI>Revised: 2002/02/15</LI>
</UL>



<H1>Abstract</H1>

When programming in functional style,
it is frequently necessary to specialize some of the
parameters of a multi-parameter procedure.
For example, from the binary operation <code>cons</code> 
one might want to obtain the unary operation 
<code>(lambda (x) (cons 1 x))</code>.
This specialization of parameters is also known as
partial application, operator section and projection.
<p>

A particularly elegant way to deal with specialization is known 
as <em>currying</em> (Sch&ouml;nfinkel 1924, Curry 1958).
The idea of currying is to reduce multi-argument functions to
single-argument functions by regarding an <i>n</i>-ary 
function as a unary function mapping its first argument into 
an (<i>n</i>-1)-ary function (which is curried in turn).
This point of view, apart from its theoretical elegance, 
allows an extremely compact notation for specializing the 
first argument of a function:
In the example above,
one could simply write <code>(cons 1)</code>.<p>

Yet, Scheme is not a curried language---the
number of arguments passed to a procedure must match
the number of its parameters at all times.
This allows zero- and variable-arity procedures 
but in order to specialize parameters
one usually has to write down a lambda-expression
and invent some irrelevant identifiers for its 
formal variables (<code>x</code> in the example).
For this reason, the mechanism proposed in this SRFI 
provides a simple and compact notation for specializing
any subset of the parameters of a procedure.
Note: <em>The mechanism proposed here is not what
is usually called "currying"!</em>
But the "macro that is not curry" is as close to
currying as it gets, as far as Scheme is concerned.<p>

The mechanism is best explained by a few examples:<p>

<TABLE>
<TR>
<TD><code>(curry cons a <>)</code> 
<TD>is the same as
<TD><code>(lambda (x2) (cons a x2))</code>
</TR>
<TR>
<TD><code>(curry list 1 <> 3 <> 5)</code> 
<TD>is the same as
<TD><code>(lambda (x2 x4) (list 1 x2 3 x4 5))</code>
</TR>
<TR>
<TD><code>(curry list)</code> 
<TD>is the same as
<TD><code>(lambda () (list))</code>
</TR>
<TR>
<TD><code>(curry list 1 <> 3 <...>)</code> 
<TD>is the same as
<TD><code>(lambda (x2 . xs) (apply list 1 x2 3 xs))</code>
</TR>
</TABLE><p>

As you see, the macro curry specializes some of the parameters of 
its first argument. The parameters that are to show up as formal
variables of the result are indicated by the symbol <code>&lt;&gt;</code>, 
pronouced as "slot". In addition, the symbol <code>&lt;...&gt;</code>,
pronounced as "rest-slot", matches all residual arguments of a variable 
argument procedure.<p>

The mechanism proposed here allows specializing any subset 
of the variables of a procedure.
The result can be of fixed arity or of variable arity.
The mechanism does not allow changing the order in which the 
arguments are passed to the procedure; 
for this it is necessary to write down a lambda-expression.

<H1>Rationale</H1>

The purpose of the mechanism proposed here is make the benefits
of currying available within the programming language Scheme.
There are two primary benefits of currying in practice:
Higher order types are substantially simplified and
there is a simple notation for specializing parameters.
The type aspect is irrelevant as has Scheme latent typing.
The specialization aspect is covered with this SRFI.<p>

Why is there no <code>uncurry</code>? 
The mechanism proposed here is in fact only a specialization of parameters. 
It does not really do currying in the sense of constructing a procedure
in one argument that returns a procedure in one argument and so on.
Hence, the specialized procedure (the result of <code>curry</code>) is
still a multi-argument procedure by nature---which renders uncurrying 
pointless.<p>

Why not real currying/uncurrying?
It is possible in Scheme to implement a macro turning a multi-argument 
procedure into a nesting of single-argument procedures and back.
This is what is usually called "currying" and "uncurrying".
Yet, Scheme remains an inherently uncurried language and is not
prepared to deal with curried procedures in a convenient way.
Hence, a "by the book" implementation of currying would only be useful
if you apply it in the sequence curry, specialize some arguments,
and uncurry again---which is exactly the purpose of the macro 
<code>curry</code> specified in this document.
The only relevant use of currying/uncurrying in Scheme are didactic
puposes to introduce the concepts of combinatory logic.
We do not think anybody would like to use both mechanisms at the
same time.<p>

Why is there another symbol for the rest-slot when lambda-expressions
use the dotted notation for variable length argument lists?
The reason is the observation by Stephan Houben that the mechanism
proposed here can also be implemented as a procedure instead of a macro,
provided there is no dotted notation. Refer to the implementation
section below.<p>

<H1>Specification</H1>

The formal syntax of a curried expression, in the style of the 
<a href="http://www.schemers.org/Documents/Standards/R5RS/"><I>Revised^5 Report on the Algorithmic Language Scheme</I></a>:

<TABLE>
<TR>
<TD><code>&lt;curried-expression&gt;</code>
<TD><code>--></code>
<TD><TD><code>(curry &lt;proc&gt; &lt;const-or-slot&gt;*)</code>
</TR>
<TR>
<TD><TD><TD>|<TD><code>(curry &lt;proc&gt; &lt;const-or-slot&gt;* <...>)</code>
</TR>
<TR>
<TD><code>&lt;proc&gt;</code>
<TD><code>--></code>
<TD><TD><code>&lt;expression&gt;</code><TD>; a procedure
</TR>
<TR>
<TD><code>&lt;const-or-slot&gt;</code>
<TD><code>--></code>
<TD><TD><code><></code><TD>; a "slot"
</TR>
<TR>
<TD><TD><TD>|<TD> <code>&lt;expression&gt;</code><TD>; a constant
</TR>
</TABLE>

The macro <code>curry</code> transforms a 
<code>&lt;curried-expression&gt;</code> into a 
<code>&lt;lambda expression&gt;</code> with as many formal variables
as there are slots in the list <code>&lt;const-or-slot&gt;*</code>.
The body of the resulting <code>&lt;lambda expression&gt;</code> calls
<code>&lt;proc&gt;</code> with the arguments from 
<code>&lt;const-or-slot&gt;*</code> in the order they appear.
In case there is a rest-slot symbol for the residual arguments 
of a variable arity procedure, the resulting procedure is also of 
variable arity and the body calls <code>&lt;proc&gt;</code> with
all arguments provided to the actual call of the specialized procedure.

<H1>Implementation</H1>

The <a href="curry.scm">reference implementation</a> defines 
the macro <code>curry</code> using macro mechanism of R5RS.
It does not use any other SRFI or any library.
The implementation makes use of a local macro of
the form <code>(curry "loop" params proc args . consts-or-slots)</code>
which collects the parameters (formals of the result) and
arguments (values eventually passed to the proc) from the 
list of constants or slots.
As macros are hygienic and referentially transparent,
the macro mechanism makes sure the names of the newly
introduced formal variables are unique and do not clash.
The template <code>(params ... slot)</code>, see <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-10.html#%_sec_7.1.5">Sect. 7.1.5. of R5RS</a>,
allows to preserve the order of arguments---which would get
reversed otherwise.<p>

As Stephan Houben observed (refer to the discussion archive), 
it is also possible to implement the mechanism proposed in 
this SRFI without macros.
The <a href="curry-mf.scm">macro-free implementation</a> defines
the slot and rest-slot symbol as markers that are recognized
in the list of constants or slots at the time <code>curry</code>
is evaluated. The result is then constructed as a procedure which
first substitutes the actual argument values for the slots and
then calls the procedure.
Note that the substitution introduces a certain run-time 
penalty as it is performed on every invocation of the 
specialized procedure.
For this reason, the macro-free implementation should only be
chosen when macros are not available.<p>

Finally, there is a small collection of 
<a href="check.scm">confidence tests</a>.
The test check some special cases of the mechanism defined
in this SRFI and signal an error in case something is wrong.
Passing the tests does not mean a correct implementation, though.

<H1>Copyright</H1>
Copyright (C) Sebastian Egner (2002). All Rights Reserved. 
<p>
This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Scheme Request For
Implementation process or editors, except as needed for the purpose of
developing SRFIs in which case the procedures for copyrights defined
in the SRFI process must be followed, or as required to translate it
into languages other than English.
<p>
The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.
<p>
This document and the information contained herein is provided on an
"AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.

    <hr>
    <address>Editor: <a href="mailto:srfi-editors@srfi.schemers.org">Mike Sperber</a></address>
    <address>Author: <a href="mailto:sebastian.egner@philips.com">Sebastian Egner</a></address>
<!-- Created: Mon Feb 4 15:20:00 EST 2002 -->
<!-- hhmts start -->
Last modified: Sat Feb 16 16:35:10 MET 2002
<!-- hhmts end -->
  </body>
</html>=