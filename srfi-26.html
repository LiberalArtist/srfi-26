<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>SRFI-26: Notation for Specializing Parameters without Currying</title>
  </head>

  <body>

<H1>Title</H1>

Notation for Specializing Parameters without Currying

<H1>Author</H1>

Sebastian Egner

<H1>Status</H1>

This SRFI is currently in ``draft'' status. To see an explanation of
each status that a SRFI can hold, see <a
href="http://srfi.schemers.org/srfi-process.html">here</a>.  It will
remain in draft until 2002-04-06, or as amended.  to provide input on
this SRFI, please
<a href="mailto:srfi-26@srfi.schemers.org">
mail to <code>srfi-26@srfi.schemers.org</code></a>.
See <a href="http://srfi.schemers.org/srfi-list-subscribe.html">
instructions here</a> to subscribe to the list.  You can access
previous messages via
<a href="http://srfi.schemers.org/srfi-26/mail-archive/maillist.html">
the archive of the mailing list</a>.

<UL>
<LI>Draft: 2002/02/06-2002/04/06 </LI>
<LI>Revised: 2002/02/15</LI>
<LI>Revised: 2002/02/28</LI>
</UL>



<H1>Abstract</H1>

When programming in functional style,
it is frequently necessary to specialize some of the
parameters of a multi-parameter procedure.
For example, from the binary operation <code>cons</code> 
one might want to obtain the unary operation 
<code>(lambda (x) (cons 1 x))</code>.
This specialization of parameters is also known as
partial application, operator section and projection.<p>

The mechanism proposed here allows to write this sort
of specialization in a simple and compact way.
The mechanism is best explained by a few examples:<p>

<TABLE>
<TR>
<TD><code>(cut cons (+ a 1) <>)</code> 
<TD>is the same as
<TD><code>(lambda (x2) (cons (+ a 1) x2))</code>
</TR>
<TR>
<TD><code>(cut list 1 <> 3 <> 5)</code> 
<TD>is the same as
<TD><code>(lambda (x2 x4) (list 1 x2 3 x4 5))</code>
</TR>
<TR>
<TD><code>(cut list)</code> 
<TD>is the same as
<TD><code>(lambda () (list))</code>
</TR>
<TR>
<TD><code>(cut list 1 <> 3 <...>)</code> 
<TD>is the same as
<TD><code>(lambda (x2 . xs) (apply list 1 x2 3 xs))</code>
</TR>
</TABLE><p>

As you see, the macro <code>cut</code> specializes some of the 
parameters of its first argument. 
The parameters that are to show up as formal
variables of the result are indicated by the symbol <code>&lt;&gt;</code>, 
pronouced as "slot". In addition, the symbol <code>&lt;...&gt;</code>,
pronounced as "rest-slot", matches all residual arguments of a variable 
argument procedure.<p>

The mechanism proposed here allows specializing any subset 
of the variables of a procedure.
The result can be of fixed arity or of variable arity.
The mechanism does not allow permutation, omission, duplication
or any other processing of the arguments;
for this it is necessary to write to use a different
mechanism such as <code>lambda</code>.

<H1>Rationale</H1>

A particularly elegant way to deal with specialization is known 
as <em>currying</em> (Sch&ouml;nfinkel 1924, Curry 1958).
The idea of currying is to reduce multi-argument functions to
single-argument functions by regarding an <i>n</i>-ary 
function as a unary function mapping its first argument into 
an (<i>n</i>-1)-ary function (which is curried in turn).
This point of view, apart from its theoretical elegance, 
allows an extremely compact notation for specializing the 
first argument of a function.
In the first example, one could simply write <code>(cons 1)</code>.<p>

Yet, Scheme is not a curried language---the
number of arguments passed to a procedure must match
the number of its parameters at all times.
This allows zero- and variable-arity procedures 
but in order to specialize parameters
one usually has to write down a lambda-expression
and invent some irrelevant identifiers for its 
formal variables (<code>x</code> in the example).
For this reason, the mechanism proposed in this SRFI 
provides a simple and compact notation for specializing
any subset of the parameters of a procedure.<p>

Note: <em>The mechanism proposed here is not currying!</em><p>

The purpose of the mechanism proposed here is to make the benefits
of currying available within the programming language Scheme.
There are two primary benefits of currying in practice:
Higher-order types are substantially simplified and
there is a simple notation for specializing parameters.
The type aspect is irrelevant as has Scheme latent typing.
The specialization aspect is largly covered with this SRFI.<p>

Here are a few more examples for illustration:

<TABLE>
<TR>
<TD><code>(map (cut * 2 <>) '(1 2 3 4))</code> 
</TR>
<TR>
<TD><code>(map (cut vector-set! x <> 0) indices)</code> 
</TR>
<TR>
<TD><code>(for-each (cut write <> port) exprs)</code> 
</TR>
<TR>
<TD><code>(apply + (map (cut if <> 0 1) '(#f #t #t #f)))</code>
</TR>
</TABLE>

<H1>Specification</H1>

The formal syntax of a specialized expression, in the style of the 
<a href="http://www.schemers.org/Documents/Standards/R5RS/"><I>Revised^5 Report on the Algorithmic Language Scheme</I></a>:

<TABLE>
<TR>
<TD><code>&lt;cut-expression&gt;</code>
<TD><code>--></code>
<TD><TD><code>(cut &lt;proc&gt; &lt;const-or-slot&gt;*)</code>
</TR>
<TR>
<TD><TD><TD>|<TD><code>(cut &lt;proc&gt; &lt;const-or-slot&gt;* <...>)</code>
</TR>
<TR>
<TD><code>&lt;proc&gt;</code>
<TD><code>--></code>
<TD><TD><code>&lt;expression&gt;</code><TD>; a procedure
</TR>
<TR>
<TD><code>&lt;const-or-slot&gt;</code>
<TD><code>--></code>
<TD><TD><code><></code><TD>; a "slot"
</TR>
<TR>
<TD><TD><TD>|<TD> <code>&lt;expression&gt;</code><TD>; 
a constant, not directly dependent on the slots
</TR>
</TABLE>

The macro <code>cut</code> transforms a 
<code>&lt;cut-expression&gt;</code> into a 
<code>&lt;lambda expression&gt;</code> with as many formal variables
as there are slots in the list <code>&lt;const-or-slot&gt;*</code>.
The body of the resulting <code>&lt;lambda expression&gt;</code> calls
<code>&lt;proc&gt;</code> with the arguments from 
<code>&lt;const-or-slot&gt;*</code> in the order they appear.
In case there is a rest-slot symbol for the residual arguments 
of a variable arity procedure, the resulting procedure is also of 
variable arity and the body calls <code>&lt;proc&gt;</code> with
all arguments provided to the actual call of the specialized procedure.<p>

The expressions at the non-slot positions (called "constant" above) and 
the expression for <code>&lt;proc&gt;</code> are evaluated at the 
time the specialized procedure is called, <em>not</em> at the time 
it is constructed.
This implies, that the meaning of a <code>&lt;cut-expression&gt;</code>
is in any respect identical to the meaning of the lambda-expression
it represents.<p>

<H1>Implementation</H1>

The following reference implementation defines the macro 
<code>cut</code> using the macro mechanism of R5RS.
It does not use any other SRFI or any library.
The implementation makes use of a local macro of
the form <code>(cut "loop" params proc args . consts-or-slots)</code>
which collects the parameters (formals of the result) and
arguments (values eventually passed to the proc) from the 
list of constants or slots.
As macros in R5RS are hygienic and referentially transparent,
the macro mechanism makes sure the names of the newly
introduced formal variables are unique and do not clash.
The template <code>(params ... slot)</code>, see <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-10.html#%_sec_7.1.5">Sect. 7.1.5. of R5RS</a>,
allows to preserve the order of arguments---which would get
reversed otherwise.
Here is the reference implementation:

<code><pre>
(define-syntax cut
  (syntax-rules (<> <...>)

    ; construct variable or fixed arity procedure
    ((cut "loop" (params ...) proc (args ...) <...>)
     (lambda (params ... . rest-slot) (apply proc args ... rest-slot)))
    ((cut "loop" (params ...) proc (args ...))
     (lambda (params ...) (proc args ...)))
				
    ; loop over &lt;const-or-slot&gt;*
    ((cut "loop" (param ...) proc (arg ...) <> . consts-or-slots)
     (cut "loop" (param ... slot) proc (arg ... slot) . consts-or-slots))
    ((cut "loop" (param ...) proc (arg ...) const . consts-or-slots)
     (cut "loop" (param ...) proc (arg ... const) . consts-or-slots))

    ; specified syntax
    ((cut proc . consts-or-slots)
     (cut "loop" () proc () . consts-or-slots))))
</pre></code>

(For those who have technical problems with copy and paste from
this page: <a href="cut.scm">Here</a> is it in a file, too.)<p>

Finally, there is a small collection of 
<a href="check.scm">confidence tests</a>.
It checks some special cases of the mechanism defined
in this SRFI and signals an error in case something is wrong.
Passing the tests does not mean a correct implementation, though.

<H1>Design Rationale</H1>

<H3>Why not real currying/uncurrying?</H3>

It is possible in Scheme to implement a macro turning a multi-argument 
procedure into a nesting of single-argument procedures and back.
These operations are usually called "curry" and "uncurry" in
other programming languages.
Yet, Scheme remains an inherently uncurried language and is not
prepared to deal with curried procedures in a convenient way.
Hence, a "by the book" implementation of currying would only be useful
if you apply it in the sequence "curry, specialize some arguments,
and uncurry again"---which is exactly the purpose of the macro 
<code>cut</code> specified in this document.
The primary relevance of currying/uncurrying in Scheme is to
teach concepts of combinatory logic.<p>

<H3>Why not a more general mechanism, also allowing permutation,
omission and duplication of arguments?</H3>

The reason is that I, the author of this SRFI, consider more general 
mechanisms too dangerous to mix them with the mechanism proposed here.
In particular, as soon as parameters are being rearranged it
is usually necessary to be aware of the meaning of the parameters;
unnamed variables can be quite harmful then.
The mechanism proposed here is designed to prevent this.
Please refer to the discussion threads
<a href="http://srfi.schemers.org/srfi-26/mail-archive/msg00018.html">"OK, how about...,"</a> (Alan Bawden),
<a href="http://srfi.schemers.org/srfi-26/mail-archive/msg00038.html">"is that useful?"</a> (Walter C. Pelissero), and
<a href="http://srfi.schemers.org/srfi-26/mail-archive/msg00040.html">"l, the ultimate curry that is not curry"</a> (Al Petrofsky).<p>

<H3>Why is the macro called <code>cut</code> and not 
[<em>enter your favourite here</em>]?</H3>

Well, the original name proposed for this SRFI was <code>curry</code>
which immediately stirred some emotions as it does not what is
commonly known as currying.
Some alternatives have been discussed, such as <code>section</code>,
<code>specialise</code>, <code>specialize</code>, <code>partial-apply</code>, 
<code>partial-call</code>, <code>partial-lambda</code>, 
<code>_j</code>, <code>_i</code>, <code>$</code>,
<code>&amp;</code>, <code>srfi-26</code>, <code>foobar</code>, 
<code>xyz</code>, <code>schoenfinkelize</code>, 
<code>curry-which-isnt-curry</code>, <code>tandoori</code>, 
and it has also been suggested to pick a five letter symbol uniformly
at random and fix this as a name.
To be fair, not all of these name have been put forward as serious proposals,
some of them were merely to illustrate a point in the discussion.
In addition, I have played with the game of the name quite a bit 
and considered other candidates not listed here.
Despite the fact that the discussion list only represents a highly
biased random sample of people's opinion (motivation to post a message
is higher if you disagree, for example) it told me that the SRFI
could potentially benefit from a different name---however impractical
it may be to go for unanimous popularity.
The name <code>cut</code> refers to "operator section", as the
concept is often called in other programming languages, 
but I tend to remember it as the acronym for "Curry Upon This" ;-).<p>

<H3>Is it possible to implement the SRFI without macros?</H3>

Not really.
As Stephan Houben has pointed out during the discussion (refer to
<a href="http://srfi.schemers.org/srfi-26/mail-archive/msg00008.html">"Implementing it as a procedure"</a>) it is possible to implement a mechanism
closely related to the one proposed in this SRFI without macros.
However, the procedural mechanism evaluates the expressions for the 
"constants" at the time the specialized procedure is being constructed. 
Refer to Al Petrovsky's posting 
<a href="http://srfi.schemers.org/srfi-26/mail-archive/msg00048.html">"Problems with "curry"'s formal specification"</a> for details.
This is in contrast to the specification of the mechanism as
defined here. Hence, the procedural implementation is not compliant
to this SRFI. One of the confidence tests checks for this.

<H3>Why is there another symbol for the rest-slot when lambda-expressions
use the dotted notation for variable length argument lists?</H3>
There are two reasons.
The first one is the existence of a procedural implementation
of a related mechanism (refer to the previous paragraph).
For a procedure, however, it is not possible to have dotted notation.
The second reason is the way the hygienic macro mechanism in R5RS
is defined to deal with dotted notation, as Felix Winkelmann has pointed out.
Refer to the discussion threads
<a href="http://srfi.schemers.org/srfi-26/mail-archive/msg00001.html">"Improper lists in macros [WAS: none]"</a>.<p>

<H1>Copyright</H1>
Copyright (C) Sebastian Egner (2002). All Rights Reserved. 
<p>
This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Scheme Request For
Implementation process or editors, except as needed for the purpose of
developing SRFIs in which case the procedures for copyrights defined
in the SRFI process must be followed, or as required to translate it
into languages other than English.
<p>
The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.
<p>
This document and the information contained herein is provided on an
"AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.

    <hr>
    <address>Editor: <a href="mailto:srfi-editors@srfi.schemers.org">Mike Sperber</a></address>
    <address>Author: <a href="mailto:sebastian.egner@philips.com">Sebastian Egner</a></address>
<!-- Created: Mon Feb 4 15:20:00 EST 2002 -->
<!-- hhmts start -->
Last modified: Fri Mar  1 09:02:11 MET 2002
<!-- hhmts end -->
  </body>
</html>=